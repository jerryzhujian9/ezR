% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/frame.R
\name{z.recode}
\alias{z.recode}
\title{recode}
\usage{
z.recode(df, varName, recodes)
}
\arguments{
\item{df}{data.frame to be recoded}

\item{varName}{the name of var to be recoded, must be a string in quotes ""}

\item{recodes}{Definition of the recoding rules. See details}
}
\value{
returns a new df, old one does not change
}
\description{
Recodes one single according to a set of rules
\cr\cr z.recode replaces the original var with recoded var;
\cr z.recode2 saves orignal var as var_ori, and then recodes var
}
\details{
recodes contains a set of recoding rules separated by ";". There are three different types of recoding rules:
\itemize{
 \item{}{The simplest codes one value to another. If we wish to recode 1 into 2, we could use the rule "1=2;".}
 \item{}{A range of values can be coded to a single value using "1:3=4;". This rule would code all values between 1 and 3 inclusive into 4. For factors, a value is between two levels if it is between them in the factor ordering. One sided ranges can be specified using the lo and hi key words (e.g."lo:3=0; 4:hi=1")}
 \item{}{Default conditions can be coded using "else." For example, if we wish to recode all values >=0 to 1 and all values <0 to missing, we could use ("0:hi=1; else=NA")}
}
}
\note{
Please note following behaviours of the function:
      \itemize{
        \item the \code{"else"}-token should be the last argument in the \code{recodes}-string.
        \item the \code{"else"}-token is optional. if not specified, simply copy over else.
        \item if multiple ranges overlap, the latter one prevails. 1:3=1;3:5=2 (3->2 finally).
        \item hi=Hi=HI=max, lo=Lo=LI=min, :=thru=Thru=THRU (mimic SPSS recode syntax)  -> can replace = as well
        \item Variable label attributes (see, for instance, \code{\link{get_label}}) are preserved if exists, however, value label attributes are removed (makes sense, right)
        \item the \code{\link[sjmisc]{rec}} function in sjmisc does not work well with double numbers (eg, 3.59)
}
}
\examples{
data<-data.frame(a=rnorm(100),b=rnorm(100),male=rnorm(100)>0)
z.recode(data[c("a","b")] , "lo:0 = 0;0:hi = 1;")
data[c("male")] <- z.recode(data[c("male")] , "1 = 'Male';0 = 'Female';else = NA;")
}
\author{
Jerry Zhu modified from Ian Fellows (pkg Deducer) adapted from code by John Fox (car)
}
\seealso{
\code{\link[tidyr]{gather}}, \code{\link[tidyr]{spread}}, \code{\link[tidyr]{separate}}, \code{\link[tidyr]{unite}}
\cr \code{\link[dplyr]{select}}, \code{\link[dplyr]{slice}}
\cr \code{\link[dplyr]{distinct}}, \code{\link[dplyr]{arrange}}
\cr \code{\link[dplyr]{summarise}}, \code{\link[dplyr]{count}}, \code{\link[dplyr]{mutate}}
\cr \code{\link[dplyr]{group_by}}, \code{\link[dplyr]{left_join}}, \code{\link[dplyr]{right_join}}, \code{\link[dplyr]{inner_join}}, \code{\link[dplyr]{full_join}}, \code{\link[dplyr]{semi_join}}, \code{\link[dplyr]{anti_join}}
\cr \code{\link[dplyr]{intersect}}, \code{\link[dplyr]{union}}, \code{\link[dplyr]{setdiff}}
\cr \code{\link[dplyr]{bind_rows}}, \code{\link[dplyr]{bind_cols}}

Other data.transformation.functions: \code{\link{z.2factor}},
  \code{\link{z.2label}}, \code{\link{z.2value}},
  \code{\link{z.compute}}, \code{\link{z.delete}},
  \code{\link{z.del}}, \code{\link{z.label.get}},
  \code{\link{z.label.set}}, \code{\link{z.leftjoin}},
  \code{\link{z.move}}, \code{\link{z.newcol}},
  \code{\link{z.recode2}}, \code{\link{z.recols}},
  \code{\link{z.recol}}, \code{\link{z.rename}},
  \code{\link{z.rncols}}, \code{\link{z.rncol}},
  \code{\link{z.select}}, \code{\link{z.sort}},
  \code{\link{z.split}}, \code{\link{z.unique}},
  \code{\link{z.values.get}}, \code{\link{z.values.set}}
}

