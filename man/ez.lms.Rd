% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stats.R
\name{ez.lms}
\alias{ez.lms}
\alias{ez.regressions}
\title{lm(y~x+covar), for many y and/or many x}
\usage{
ez.lms(df, y, x, covar = NULL, report = T, model = c("lm", "lmrob",
  "lmRob", "rlm"), view = F, plot = F, pmethods = c("bonferroni", "fdr"),
  cols = 3, labsize = 2, textsize = 1.5, titlesize = 3, error = T,
  ...)

ez.regressions(df, y, x, covar = NULL, report = T, model = c("lm",
  "lmrob", "lmRob", "rlm"), view = F, plot = F, pmethods = c("bonferroni",
  "fdr"), cols = 3, labsize = 2, textsize = 1.5, titlesize = 3,
  error = T, ...)
}
\arguments{
\item{df}{a data frame. Internally go through dropna-->ez.2value-->scale
\cr because of this, this function is not friendly to factors with 3 or more levels, although the default lm can handel factors nicely (yet complicatedly--eg, not easy to test significance)
\cr by design, ez.2value to convert factors with 2 levels, such as sex, this generates the same results as lm by default, see note and example below for more
\cr scale to get standarized beta as effect size for comparison across different variables}

\item{y}{compatible with \code{\link{ez.selcol}}}

\item{x}{compatible with \code{\link{ez.selcol}}}

\item{covar}{NULL=no covar, compatible with \code{\link{ez.selcol}}}

\item{report}{print results (in APA format)}

\item{model}{vector c('lm', 'lmrob', 'lmRob', 'rlm'), robustbase::lmrob--MM-type Estimators; robust::lmRob--automatically chooses an appropriate algorithm. one or more, 'lm' will always be included internally, even if not specified}

\item{view}{call View(result)}

\item{plot}{T/F, the black dash line is bonferroni p = 0.05 (again for tests only with a non-NA p values), the grey black dash is uncorrected p = 0.05}

\item{pmethods}{c('bonferroni','fdr'), type p.adjust.methods for all methods. This correction is based on the total number of tests that successfully generate p values}

\item{cols}{number of columns for multiplot. NULL=auto calculate}

\item{error}{whether show error message when error occurs (also result will have an empty row when error occurs)}

\item{...}{additional parameters to the specified model. if more than one model specified, ... may not be OK for all models, because diff models have diff parameters}
}
\value{
an invisible data frame or list of data frame (if many y and many x)
\cr beta: standardized beta coefficients (simple or multiple regression) are the estimates resulting from a regression analysis that have been standardized
\cr so that the variances of dependent and independent variables are 1.
\cr Therefore, standardized coefficients refer to how many standard deviations a dependent variable will change,
\cr per standard deviation increase in the predictor variable.
\cr For simple regression (1 y ~ 1 x), the value of the standardized coefficient (beta) equals the correlation coefficient (r) (beta=r).
\cr For multiple regression (with covar), the value of the standardized coefficient (beta) is close to semi-partial correlation
\cr According to jerry testing, scale() or not for x,y or covar, does not change p values for predictors, although intercept would differ
\cr 
\cr dof: from F-statistic
\cr residualization: say, y ~ x + a + b, first x ~ a + b is residualized and then y ~ x (ie, semi-partial). If no covar, y ~ x, although labelled residualized in result data frame, actually non-residualized
\cr as far as semi-partial concerned, y ~ x + a + b, x ~ y + a + b are two different models. ppcor::spcor.test(iris[,1],iris[,2],iris[,c(3,4)]) != ppcor::spcor.test(iris[,2],iris[,1],iris[,c(3,4)])
\cr but for partial correlation, partial(y,x) is the same as partial(x,y), ppcor::pcor.test(iris[,1],iris[,2],iris[,c(3,4)]) = ppcor::pcor.test(iris[,2],iris[,1],iris[,c(3,4)])
\cr On a related note, y ~ x + a + b, generates the same results as y ~ b + a + x (the order does not matter). 
\cr For coding purpose, I put x as x, and (a,b) as cov. stdbeta, p returned refer to x, values referring to a,b were discarded during the process.
\cr 
\cr 
\cr !!!important note!!!
\cr the stdbeta, p(.lm), p.lmrob etc in result data frame refer to stdbeta, p value for x in a (multiple) regression, which are plotted when plot=T. the bestp is also selected based on this p value
\cr the r.residualized, p.residualized refers to semi-partial correlation, which are printed out when view=T
\cr no column named r, r.lm, r.lmrob etc in the result data frame
\cr 
\cr
}
\description{
lm(y~x+covar), for many y and/or many x
}
\note{
To keep consistent with other R functions (eg, lm which converts numeric/non-numeric factor to values starting from 0), set start.at=0 in ez.2value(), then factor(1:2)->c(0,1), factor(c('girl','boy'))->c(1,0) # the level order is boy,girl
\cr in lm() the coding (0,1) vs.(1,2) does not affect slope, but changes intercept (but a coding from 1,2->1,3 would change slope--interval difference matters)
}
